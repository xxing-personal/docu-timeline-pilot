import fs from 'fs/promises';
import path from 'path';
import pdfParse from 'pdf-parse';
import OpenAI from 'openai';
import { PDFTask, PDFProcessingResult } from '../types';

export class PDFProcessor {
  private openai: OpenAI;
  private extractedTextDir: string;

  constructor() {
    // Initialize OpenAI client
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    
    // Create directory for extracted text files
    this.extractedTextDir = path.join(process.cwd(), 'extracted-texts');
    this.ensureExtractedTextDir();
  }

  private async ensureExtractedTextDir(): Promise<void> {
    try {
      await fs.access(this.extractedTextDir);
    } catch {
      await fs.mkdir(this.extractedTextDir, { recursive: true });
      console.log(`[PDF PROCESSOR] Created extracted text directory: ${this.extractedTextDir}`);
    }
  }

  private async saveExtractedTextToFile(filename: string, extractedText: string): Promise<string> {
    // Create a safe filename for the markdown file
    const safeFilename = filename.replace(/[^a-zA-Z0-9.-]/g, '_');
    const markdownFilename = `${safeFilename}_extracted.md`;
    const filePath = path.join(this.extractedTextDir, markdownFilename);
    
    // Create markdown content with metadata
    const markdownContent = `# Extracted Text: ${filename}

## Document Information
- **Original Filename**: ${filename}
- **Extraction Date**: ${new Date().toISOString()}
- **Text Length**: ${extractedText.length} characters
- **Word Count**: ${extractedText.split(/\s+/).length} words

## Extracted Content

${extractedText}

---
*This file was automatically generated by the PDF Processor.*
`;

    // Write the markdown file asynchronously
    await fs.writeFile(filePath, markdownContent, 'utf8');
    console.log(`[PDF PROCESSOR] Saved extracted text to: ${filePath}`);
    
    return filePath;
  }

  async process(task: PDFTask): Promise<PDFProcessingResult> {
    console.log(`[PDF PROCESSOR] Starting processing for: ${task.filename} (Task ID: ${task.id})`);
    
    try {
      // Check if file still exists
      try {
        await fs.access(task.path);
      } catch {
        throw new Error(`File not found: ${task.path}`);
      }
      
      // Get file stats
      const stats = await fs.stat(task.path);
      
      // Extract text from PDF - this is where the actual processing work begins
      console.log(`[PDF PROCESSOR] Beginning text extraction from: ${task.filename}`);
      const extractedText = await this.extractTextFromPDF(task.path);
      
      // Save extracted text to markdown file
      console.log(`[PDF PROCESSOR] Saving extracted text to file for: ${task.filename}`);
      const extractedTextPath = await this.saveExtractedTextToFile(task.filename, extractedText);
      
      // Generate summary using OpenAI
      console.log(`[PDF PROCESSOR] Generating AI summary for: ${task.filename}`);
      const summary = await this.generatePlaceholderSummary(extractedText, task.filename);
      
      // Get page count from pdf-parse results
      const pdfBuffer = await fs.readFile(task.path);
      const pdfData = await pdfParse(pdfBuffer);
      
      const result: PDFProcessingResult = {
        filename: task.filename,
        processedAt: new Date().toISOString(),
        extractedTextPath: extractedTextPath, // Return the path instead of the text
        summary: summary,
        pageCount: pdfData.numpages,
        fileSize: stats.size,
        metadata: {
          createdAt: stats.birthtime,
          modifiedAt: stats.mtime,
          processingDuration: Date.now(), // Will be calculated later
          pdfInfo: pdfData.info || {},
          textLength: extractedText.length,
          summaryLength: summary.length
        }
      };
      
      console.log(`[PDF PROCESSOR] Successfully completed processing: ${task.filename} (${pdfData.numpages} pages, ${extractedText.length} chars)`);
      return result;
      
    } catch (error) {
      console.error(`Error processing PDF ${task.filename}:`, error);
      throw new Error(`Failed to process PDF: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  private async extractTextFromPDF(filePath: string): Promise<string> {
    try {
      const pdfBuffer = await fs.readFile(filePath);
      const pdfData = await pdfParse(pdfBuffer);
      
      // Clean up the extracted text
      let text = pdfData.text;
      
      // Basic text cleanup
      text = text
        .replace(/\n\s*\n/g, '\n\n') // Remove excessive line breaks
        .replace(/\s+/g, ' ') // Normalize whitespace
        .trim();
      
      if (!text || text.length < 10) {
        throw new Error('No readable text found in PDF - document may be image-based or encrypted');
      }
      
      return text;
      
    } catch (error) {
      console.error('Text extraction error:', error);
      throw new Error(`Text extraction failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  private async generateSummary(text: string, filename: string): Promise<string> {
    try {
      // Check if OpenAI API key is available
      if (!process.env.OPENAI_API_KEY) {
        console.warn('OpenAI API key not found, generating placeholder summary');
        return this.generatePlaceholderSummary(text, filename);
      }
      
      // Truncate text if it's too long (GPT has token limits)
      const maxChars = 12000; // Roughly 3000 tokens
      const truncatedText = text.length > maxChars ? text.substring(0, maxChars) + '...' : text;
      
      const completion = await this.openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [
          {
            role: "system",
            content: "You are an expert document analyst. Provide a concise, informative summary of the document content. Focus on key points, main topics, and important details. Keep the summary between 150-300 words."
          },
          {
            role: "user",
            content: `Please summarize the following document content from "${filename}":\n\n${truncatedText}`
          }
        ],
        max_tokens: 500,
        temperature: 0.3
      });
      
      const summary = completion.choices[0]?.message?.content;
      
      if (!summary) {
        throw new Error('No summary generated by OpenAI');
      }
      
      return summary.trim();
      
    } catch (error) {
      console.error('Summary generation error:', error);
      console.log('Falling back to placeholder summary');
      return this.generatePlaceholderSummary(text, filename);
    }
  }
  
  private generatePlaceholderSummary(text: string, filename: string): string {
    // Generate a basic summary when OpenAI is not available
    const words = text.split(/\s+/);
    const totalWords = words.length;
    const chars = text.length;
    
    // Extract first few sentences as a basic summary
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 10);
    const firstSentences = sentences.slice(0, 3).join('. ').trim();
    
    return `Document Summary for ${filename}:

This document contains ${totalWords} words across ${chars} characters. 

Key content preview: ${firstSentences}${firstSentences.endsWith('.') ? '' : '.'}

Note: This is a basic text analysis. For AI-powered summarization, configure the OPENAI_API_KEY environment variable.`;
  }

  // Method to validate PDF file
  async validatePDF(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      
      // Use pdf-parse to validate the PDF
      const pdfBuffer = await fs.readFile(filePath);
      await pdfParse(pdfBuffer);
      return true;
      
    } catch (error) {
      console.error('PDF validation error:', error);
      return false;
    }
  }
  
  // Method to get PDF metadata without full processing
  async getMetadata(filePath: string): Promise<Record<string, any>> {
    try {
      const stats = await fs.stat(filePath);
      const pdfBuffer = await fs.readFile(filePath);
      const pdfData = await pdfParse(pdfBuffer);
      
      return {
        fileSize: stats.size,
        createdAt: stats.birthtime,
        modifiedAt: stats.mtime,
        pageCount: pdfData.numpages,
        pdfInfo: pdfData.info || {},
        textPreview: pdfData.text.substring(0, 200) + '...'
      };
    } catch (error) {
      console.error('Metadata extraction error:', error);
      return {
        fileSize: 0,
        error: 'Failed to extract PDF metadata'
      };
    }
  }
} 