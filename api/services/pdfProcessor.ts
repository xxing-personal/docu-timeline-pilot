import fs from 'fs/promises';
import path from 'path';
import pdfParse from 'pdf-parse';
import { callReasoningModel } from './openaiUtil';
import { PDFTask, PDFProcessingResult } from '../types';
import { IndicesDatabaseService } from './indicesDatabaseService';

export class PdfProcessor {
  private extractedTextsDir: string;
  private indicesDb: IndicesDatabaseService;

  constructor() {
    this.extractedTextsDir = path.join(process.cwd(), 'extracted-texts');
    this.ensureDirectoriesExist();
    this.indicesDb = new IndicesDatabaseService();
  }

  private async ensureDirectoriesExist(): Promise<void> {
    try {
      await fs.mkdir(this.extractedTextsDir, { recursive: true });
    } catch (error) {
      console.error('[PDF PROCESSOR] Error creating directories:', error);
    }
  }

  private async saveExtractedTextToFile(filename: string, extractedText: string): Promise<string> {
    // Create a safe filename for the markdown file
    const safeFilename = filename.replace(/[^a-zA-Z0-9.-]/g, '_');
    const markdownFilename = `${safeFilename}_extracted.md`;
    const filePath = path.join(this.extractedTextsDir, markdownFilename);
    
    // Create markdown content with metadata
    const markdownContent = `# Extracted Text: ${filename}

## Document Information
- **Original Filename**: ${filename}
- **Extraction Date**: ${new Date().toISOString()}
- **Text Length**: ${extractedText.length} characters
- **Word Count**: ${extractedText.split(/\s+/).length} words

## Extracted Content

${extractedText}

---
*This file was automatically generated by the PDF Processor.*
`;

    // Write the markdown file asynchronously
    await fs.writeFile(filePath, markdownContent, 'utf8');
    console.log(`[PDF PROCESSOR] Saved extracted text to: ${filePath}`);
    
    return filePath;
  }

  private async extractTextFromPDF(filePath: string): Promise<string> {
    try {
      const pdfBuffer = await fs.readFile(filePath);
      const pdfData = await pdfParse(pdfBuffer);
      
      // Clean up the extracted text
      let text = pdfData.text;
      
      // Basic text cleanup
      text = text
        .replace(/\n\s*\n/g, '\n\n') // Remove excessive line breaks
        .replace(/\s+/g, ' ') // Normalize whitespace
        .trim();
      
      if (!text || text.length < 10) {
        throw new Error('No readable text found in PDF - document may be image-based or encrypted');
      }
      
      return text;
      
    } catch (error) {
      console.error('Text extraction error:', error);
      throw new Error(`Text extraction failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private async generateSummary(text: string, filename: string): Promise<string> {
    try {
      // Check if OpenAI API key is available
      if (!process.env.OPENAI_API_KEY) {
        console.warn('OpenAI API key not found, generating placeholder summary');
        return this.generatePlaceholderSummary(text, filename);
      }
      
      // Truncate text if it's too long (GPT has token limits)
      const maxChars = 12000; // Roughly 3000 tokens
      const truncatedText = text.length > maxChars ? text.substring(0, maxChars) + '...' : text;
      
      const systemPrompt = 'You are a helpful assistant that analyzes documents and extracts structured information. You must respond with valid JSON only, without any markdown formatting or code blocks.';
      
      const userPrompt = `Please analyze the following document content from "${filename}" and provide a comprehensive summary in JSON format.

Document content:
${truncatedText}

Please respond with a JSON object containing:
1. ONE_SENTENCE_SUMMARY: A concise one-sentence summary of the document
2. BULLET_POINTS: Array of 3-6 key bullet points highlighting main topics and important details
3. CONFIDENCE_INDEX: A number between 0-1 indicating your confidence in the accuracy of your analysis (0 = very uncertain, 1 = very confident)
4. SENTIMENT_INDEX: A number between 0-1 indicating the overall sentiment of the document (0 = very negative, 0.5 = neutral, 1 = very positive)
5. INFERRED_TIMESTAMP: If you can identify a clear date or timestamp from the document content (like "created on", "dated", "published", "issued", etc.), provide it in ISO 8601 format (YYYY-MM-DDTHH:mm:ss.sssZ). If no clear timestamp is found, respond with "NOT_FOUND".

Example response:
{
  "ONE_SENTENCE_SUMMARY": "This document discusses quarterly financial results showing positive growth.",
  "BULLET_POINTS": [
    "Revenue increased by 15% compared to previous quarter",
    "New product launches contributed significantly to growth",
    "Market expansion into emerging markets shows promise"
  ],
  "CONFIDENCE_INDEX": 0.9,
  "SENTIMENT_INDEX": 0.7,
  "INFERRED_TIMESTAMP": "2024-03-15T10:00:00.000Z"
}

Respond only with the JSON object, no additional text or markdown formatting.`;

      const response = await callReasoningModel(systemPrompt, userPrompt, '[PDF PROCESSOR]');
      
      if (!response.success || !response.text) {
        throw new Error(response.error || 'No response generated by OpenAI');
      }
      
      console.log(`[PDF PROCESSOR] OpenAI response: ${response.text}`);
      return response.text;
      
    } catch (error) {
      console.error('Summary generation error:', error);
      console.log('Falling back to placeholder summary');
      return this.generatePlaceholderSummary(text, filename);
    }
  }

  private generatePlaceholderSummary(text: string, filename: string): string {
    // Generate a basic summary when OpenAI is not available
    const words = text.split(/\s+/);
    const totalWords = words.length;
    const chars = text.length;
    
    // Extract first few sentences as a basic summary
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 10);
    const firstSentences = sentences.slice(0, 3).join('. ').trim();
    
    return `ONE_SENTENCE_SUMMARY: This document contains ${totalWords} words and appears to be a text-based document requiring AI analysis for detailed summarization.

BULLET_POINTS:
• Document contains ${totalWords} words across ${chars} characters
• Text appears to be readable and extractable from PDF format
• Content preview: ${firstSentences}${firstSentences.endsWith('.') ? '' : '.'}
• Document filename: ${filename}
• Analysis method: Basic text extraction (AI summarization not available)
• For enhanced analysis, configure OPENAI_API_KEY environment variable

CONFIDENCE_INDEX: 0.3
SENTIMENT_INDEX: 0.5
INFERRED_TIMESTAMP: NOT_FOUND`;
  }

  // Method to validate PDF file
  async validatePDF(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      
      // Use pdf-parse to validate the PDF
      const pdfBuffer = await fs.readFile(filePath);
      await pdfParse(pdfBuffer);
      return true;
      
    } catch (error) {
      console.error('PDF validation error:', error);
      return false;
    }
  }

  // Method to get PDF metadata without full processing
  async getMetadata(filePath: string): Promise<Record<string, any>> {
    try {
      const stats = await fs.stat(filePath);
      const pdfBuffer = await fs.readFile(filePath);
      const pdfData = await pdfParse(pdfBuffer);
      
      return {
        fileSize: stats.size,
        createdAt: stats.birthtime,
        modifiedAt: stats.mtime,
        pageCount: pdfData.numpages,
        pdfInfo: pdfData.info || {},
        textPreview: pdfData.text.substring(0, 200) + '...'
      };
    } catch (error) {
      console.error('Metadata extraction error:', error);
      return {
        fileSize: 0,
        error: 'Failed to extract PDF metadata'
      };
    }
  }

  async process(task: PDFTask): Promise<PDFProcessingResult> {
    console.log(`[PDF PROCESSOR] Starting processing for: ${task.filename} (Task ID: ${task.id})`);
    
    try {
      // Check if file still exists
      try {
        await fs.access(task.path);
      } catch {
        throw new Error(`File not found: ${task.path}`);
      }
      
      // Get file stats
      const stats = await fs.stat(task.path);
      
      // Extract text from PDF - this is where the actual processing work begins
      console.log(`[PDF PROCESSOR] Beginning text extraction from: ${task.filename}`);
      const extractedText = await this.extractTextFromPDF(task.path);
      
      // Save extracted text to markdown file
      console.log(`[PDF PROCESSOR] Saving extracted text to file for: ${task.filename}`);
      const extractedTextPath = await this.saveExtractedTextToFile(task.filename, extractedText);
      
      // Analyze document with AI
      console.log(`[PDF PROCESSOR] Analyzing document with AI for: ${task.filename}`);
      const analysis = await this.generateSummary(extractedText, task.filename);
      
      // Parse inferred timestamp from summary
      const inferredTimestamp = this.parseInferredTimestamp(analysis);
      if (inferredTimestamp) {
        console.log(`[PDF PROCESSOR] Inferred timestamp found: ${inferredTimestamp} for ${task.filename}`);
        await this.updateFileTimestamps(task.filename, inferredTimestamp);
      } else {
        console.log(`[PDF PROCESSOR] No valid timestamp inferred for ${task.filename}`);
      }

      // Parse all *_INDEX fields from summary
      const analysisScores: Record<string, number> = {};
      const indexPattern = /([A-Z_]+_INDEX):\s*([0-9.]+)/g;
      let match;
      while ((match = indexPattern.exec(analysis)) !== null) {
        const key = match[1].replace('_INDEX', '').toLowerCase();
        const value = parseFloat(match[2]);
        if (!isNaN(value)) {
          analysisScores[key] = value;
        }
      }
      
      // Save indices to the indices database if any were found
      console.log(`[PDF PROCESSOR] Found ${Object.keys(analysisScores).length} analysis scores for ${task.filename}:`, analysisScores);
      if (Object.keys(analysisScores).length > 0) {
        try {
          console.log(`[PDF PROCESSOR] Attempting to save indices to database for ${task.filename}`);
          await this.indicesDb.addPdfProcessingIndex(
            task.id,
            task.filename,
            analysisScores,
            inferredTimestamp || undefined,
            task.id
          );
          console.log(`[PDF PROCESSOR] Successfully saved indices to database for ${task.filename}`);
        } catch (error) {
          console.error(`[PDF PROCESSOR] Failed to save indices to database for ${task.filename}:`, error);
        }
      } else {
        console.log(`[PDF PROCESSOR] No analysis scores found for ${task.filename}`);
      }
      
      // Get page count from pdf-parse results
      const pdfBuffer = await fs.readFile(task.path);
      const pdfData = await pdfParse(pdfBuffer);
      
      const result: PDFProcessingResult = {
        filename: task.filename,
        processedAt: new Date().toISOString(),
        extractedTextPath: extractedTextPath, // Return the path instead of the text
        summary: analysis,
        pageCount: pdfData.numpages,
        fileSize: stats.size,
        metadata: {
          createdAt: stats.birthtime,
          modifiedAt: stats.mtime,
          processingDuration: Date.now(), // Will be calculated later
          pdfInfo: pdfData.info || {},
          textLength: extractedText.length,
          summaryLength: analysis.length,
          inferredTimestamp: inferredTimestamp || null,
          analysisScores
        }
      };
      
      console.log(`[PDF PROCESSOR] Successfully completed processing: ${task.filename} (${pdfData.numpages} pages, ${extractedText.length} chars)`);
      return result;
      
    } catch (error) {
      console.error(`Error processing PDF ${task.filename}:`, error);
      throw new Error(`Failed to process PDF: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private parseInferredTimestamp(summary: string): string | null {
    const lines = summary.split('\n');
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith('INFERRED_TIMESTAMP:')) {
        const timestamp = trimmedLine.replace('INFERRED_TIMESTAMP:', '').trim();
        if (timestamp === 'NOT_FOUND') {
          return null;
        }
        // Validate that it's a proper ISO timestamp
        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/.test(timestamp)) {
          return timestamp;
        }
      }
    }
    return null;
  }

  private async updateFileTimestamps(filename: string, inferredTimestamp: string): Promise<void> {
    try {
      // Update the actual PDF file timestamps
      const pdfFilePath = path.join(process.cwd(), '../uploads', filename);
      const timestamp = new Date(inferredTimestamp);
      
      // Update file modification time
      await fs.utimes(pdfFilePath, timestamp, timestamp);
      
      console.log(`[PDF PROCESSOR] Updated file timestamps for: ${filename} to ${inferredTimestamp}`);
    } catch (error) {
      console.error(`Error updating file timestamps for ${filename}:`, error);
    }
  }
} 