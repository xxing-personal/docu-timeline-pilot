import fs from 'fs/promises';
import path from 'path';
import pdfParse from 'pdf-parse';
import { callReasoningModel, extractJsonFromResponse } from './ModelUtils';
import { PDFTask, PDFProcessingResult } from '../types';
import { IndicesDatabaseService } from './indicesDatabaseService';

export class PdfProcessor {
  private extractedTextsDir: string;
  private indicesDb: IndicesDatabaseService;

  constructor() {
    this.extractedTextsDir = path.join(process.cwd(), 'extracted-texts');
    this.ensureDirectoriesExist();
    this.indicesDb = new IndicesDatabaseService();
  }

  private async ensureDirectoriesExist(): Promise<void> {
    try {
      await fs.mkdir(this.extractedTextsDir, { recursive: true });
    } catch (error) {
      console.error('[PDF PROCESSOR] Error creating directories:', error);
    }
  }

  private async saveExtractedTextToFile(filename: string, extractedText: string): Promise<string> {
    // Create a safe filename for the markdown file
    const safeFilename = filename.replace(/[^a-zA-Z0-9.-]/g, '_');
    const markdownFilename = `${safeFilename}_extracted.md`;
    const filePath = path.join(this.extractedTextsDir, markdownFilename);
    
    // Create markdown content with metadata
    const markdownContent = `# Extracted Text: ${filename}

## Document Information
- **Original Filename**: ${filename}
- **Extraction Date**: ${new Date().toISOString()}
- **Text Length**: ${extractedText.length} characters
- **Word Count**: ${extractedText.split(/\s+/).length} words

## Extracted Content

${extractedText}

---
*This file was automatically generated by the PDF Processor.*
`;

    // Write the markdown file asynchronously
    await fs.writeFile(filePath, markdownContent, 'utf8');
    console.log(`[PDF PROCESSOR] Saved extracted text to: ${filePath}`);
    
    return filePath;
  }

  private async extractTextFromPDF(filePath: string): Promise<string> {
    try {
      const pdfBuffer = await fs.readFile(filePath);
      const pdfData = await pdfParse(pdfBuffer);
      
      // Clean up the extracted text
      let text = pdfData.text;
      
      // Basic text cleanup
      text = text
        .replace(/\n\s*\n/g, '\n\n') // Remove excessive line breaks
        .replace(/\s+/g, ' ') // Normalize whitespace
        .trim();
      
      if (!text || text.length < 10) {
        throw new Error('No readable text found in PDF - document may be image-based or encrypted');
      }
      
      return text;
      
    } catch (error) {
      console.error('Text extraction error:', error);
      throw new Error(`Text extraction failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private async generateSummary(text: string, filename: string): Promise<any> {
    try {
      // Check if OpenAI API key is available
      if (!process.env.OPENAI_API_KEY) {
        throw new Error('OpenAI API key not found. Please configure OPENAI_API_KEY environment variable.');
      }
      
      // Truncate text if it's too long (GPT has token limits)
      const maxChars = 12000; // Roughly 3000 tokens
      const truncatedText = text.length > maxChars ? text.substring(0, maxChars) + '...' : text;
      
      const systemPrompt = 'You are a helpful assistant that analyzes documents and extracts structured information. You must respond with valid JSON only, without any markdown formatting or code blocks.';
      
      const userPrompt = `Please analyze the following document content from "${filename}" and provide a comprehensive summary in JSON format.

Document content:
${truncatedText}

Please respond with a JSON object containing:
1. ONE_SENTENCE_SUMMARY: A concise one-sentence summary of the document
2. BULLET_POINTS: Array of 3-6 key bullet points highlighting main topics and important details
3. INFERRED_TIMESTAMP: If you can identify a clear date or timestamp from the document content (like "created on", "dated", "published", "issued", etc.), provide it in ISO 8601 format (YYYY-MM-DDTHH:mm:ss.sssZ). If no clear timestamp is found, respond with "NOT_FOUND".

Example response:
{
  "ONE_SENTENCE_SUMMARY": "This document discusses quarterly financial results showing positive growth.",
  "BULLET_POINTS": [
    "Revenue increased by 15% compared to previous quarter",
    "New product launches contributed significantly to growth",
    "Market expansion into emerging markets shows promise"
  ],
  "INFERRED_TIMESTAMP": "2024-03-15T10:00:00.000Z"
}

Respond only with the JSON object, no additional text or markdown formatting.`;

      const response = await callReasoningModel(systemPrompt, userPrompt, '[PDF PROCESSOR]');
      
      if (!response.success || !response.text) {
        throw new Error(response.error || 'No response generated by OpenAI');
      }
      
      console.log(`[PDF PROCESSOR] OpenAI response: ${response.text}`);
      
      // Extract and parse JSON from response
      const jsonText = extractJsonFromResponse(response.text);
      console.log(`[PDF PROCESSOR] Extracted JSON text: ${jsonText}`);
      
      try {
        const parsedAnalysis = JSON.parse(jsonText);
        console.log(`[PDF PROCESSOR] Parsed JSON analysis:`, parsedAnalysis);
        return parsedAnalysis;
      } catch (parseError) {
        console.error('[PDF PROCESSOR] Error parsing JSON from response:', parseError);
        throw new Error(`Failed to parse OpenAI response as JSON: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`);
      }
      
    } catch (error) {
      console.error('Summary generation error:', error);
      throw error;
    }
  }

  // Method to validate PDF file
  async validatePDF(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      
      // Use pdf-parse to validate the PDF
      const pdfBuffer = await fs.readFile(filePath);
      await pdfParse(pdfBuffer);
      return true;
      
    } catch (error) {
      console.error('PDF validation error:', error);
      return false;
    }
  }

  // Method to get PDF metadata without full processing
  async getMetadata(filePath: string): Promise<Record<string, any>> {
    try {
      const stats = await fs.stat(filePath);
      const pdfBuffer = await fs.readFile(filePath);
      const pdfData = await pdfParse(pdfBuffer);
      
      return {
        fileSize: stats.size,
        createdAt: stats.birthtime,
        modifiedAt: stats.mtime,
        pageCount: pdfData.numpages,
        pdfInfo: pdfData.info || {},
        textPreview: pdfData.text.substring(0, 200) + '...'
      };
    } catch (error) {
      console.error('Metadata extraction error:', error);
      return {
        fileSize: 0,
        error: 'Failed to extract PDF metadata'
      };
    }
  }

  async process(task: PDFTask): Promise<PDFProcessingResult> {
    console.log(`[PDF PROCESSOR] Starting processing for: ${task.filename} (Task ID: ${task.id})`);
    
    try {
      // Check if file still exists
      try {
        await fs.access(task.path);
      } catch {
        throw new Error(`File not found: ${task.path}`);
      }
      
      // Get file stats
      const stats = await fs.stat(task.path);
      
      // Extract text from PDF - this is where the actual processing work begins
      console.log(`[PDF PROCESSOR] Beginning text extraction from: ${task.filename}`);
      const extractedText = await this.extractTextFromPDF(task.path);
      
      // Save extracted text to markdown file
      console.log(`[PDF PROCESSOR] Saving extracted text to file for: ${task.filename}`);
      const extractedTextPath = await this.saveExtractedTextToFile(task.filename, extractedText);
      
      // Analyze document with AI
      console.log(`[PDF PROCESSOR] Analyzing document with AI for: ${task.filename}`);
      const analysis = await this.generateSummary(extractedText, task.filename);
      
      // Extract data from parsed JSON analysis
      const inferredTimestamp = analysis.INFERRED_TIMESTAMP && analysis.INFERRED_TIMESTAMP !== 'NOT_FOUND' 
        ? analysis.INFERRED_TIMESTAMP 
        : null;
      
      if (inferredTimestamp) {
        console.log(`[PDF PROCESSOR] Inferred timestamp found: ${inferredTimestamp} for ${task.filename}`);
        await this.updateFileTimestamps(task.filename, inferredTimestamp);
      } else {
        console.log(`[PDF PROCESSOR] No valid timestamp inferred for ${task.filename}`);
      }

      // Note: Analysis scores (confidence/sentiment indices) have been removed from PDF processing
      
      // Get page count from pdf-parse results
      const pdfBuffer = await fs.readFile(task.path);
      const pdfData = await pdfParse(pdfBuffer);
      
      const result: PDFProcessingResult = {
        filename: task.filename,
        processedAt: new Date().toISOString(),
        extractedTextPath: extractedTextPath, // Return the path instead of the text
        summary: JSON.stringify(analysis), // Convert back to string for storage
        pageCount: pdfData.numpages,
        fileSize: stats.size,
        metadata: {
          createdAt: stats.birthtime,
          modifiedAt: stats.mtime,
          processingDuration: Date.now(), // Will be calculated later
          pdfInfo: pdfData.info || {},
          textLength: extractedText.length,
          summaryLength: JSON.stringify(analysis).length,
          inferredTimestamp: inferredTimestamp || null
        }
      };
      
      console.log(`[PDF PROCESSOR] Successfully completed processing: ${task.filename} (${pdfData.numpages} pages, ${extractedText.length} chars)`);
      return result;
      
    } catch (error) {
      console.error(`Error processing PDF ${task.filename}:`, error);
      throw new Error(`Failed to process PDF: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private async updateFileTimestamps(filename: string, inferredTimestamp: string): Promise<void> {
    try {
      // Update the actual PDF file timestamps
      const pdfFilePath = path.join(process.cwd(), '../uploads', filename);
      const timestamp = new Date(inferredTimestamp);
      
      // Update file modification time
      await fs.utimes(pdfFilePath, timestamp, timestamp);
      
      console.log(`[PDF PROCESSOR] Updated file timestamps for: ${filename} to ${inferredTimestamp}`);
    } catch (error) {
      console.error(`Error updating file timestamps for ${filename}:`, error);
    }
  }
} 